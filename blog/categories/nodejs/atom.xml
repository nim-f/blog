<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nodejs | Заметки о фронтэнде]]></title>
  <link href="http://nim-f.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://nim-f.github.io/"/>
  <updated>2016-01-09T20:29:45+02:00</updated>
  <id>http://nim-f.github.io/</id>
  <author>
    <name><![CDATA[Ann R]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Как облегчить себе жизнь с помощью Gulp, Jade, Stylus и Yeoman]]></title>
    <link href="http://nim-f.github.io/blog/2016/01/09/scaffolding-frontend-with-gulp-and-yeoman/"/>
    <updated>2016-01-09T19:33:08+02:00</updated>
    <id>http://nim-f.github.io/blog/2016/01/09/scaffolding-frontend-with-gulp-and-yeoman</id>
    <content type="html"><![CDATA[<p>В работе фрондэнд разработчика есть существенный недостаток - обилие рутинных задач, которые повторяются в каждом проекте. Либо настраивать для каждого проекта сборщик (Gulp или Grunt), шаблонизатор, препроцессор, подключить файлы скриптов и css, а потом создавать html-файл и писать в нем одни и те же обязательные теги, либо вообще не заморачиваться с модными штучками и хардкодить по-старинке на статичном html/css… И то, и другое довольно скучно и занимает массу драгоценного времени. Однажды некоторым особо-продвинутым фронтэндерам пришло в голову собирать для себя стартовый шаблон проекта и начинать разработку не с массы однообразных действий, а с команды git clone «бла-бла-бла». Но человеческая лень пошла дальше, и появился Yeoman - инструмент скаффолдинга проектов (и их отдельных частей).</p>

<p><img src="http://nim-f.github.io/images/yeoman.png" alt="Yeoman" /></p>

<p>Тут надо пояснить, что такое вообще этот скаффолдинг. Тем, кто знаком с Ruby on Rails и некоторыми другими фреймворками, слово покажется знакомым. Там команда generate scaffold широко используется для генерации каркаса приложения и отдельных его частей  - моделей, контроллеров и представлений. В случае с Yeoman генерируется целый проект - это может быть обычное веб- или мобильное приложение или шаблон для разработки с использованием фреймворка - Angular.js, React.js, Backbone.js и тд. Полный список генераторов здесь - <a href="http://yeoman.io/generators/.">http://yeoman.io/generators/.</a> Впрочем, этот список можно расширить, написав генератор самостоятельно, если существующие не устраивают.</p>

<!-- more -->


<p>Как установить Yeoman и популярный генератор webapp рассказывается в официальной документации - <a href="http://yeoman.io/.">http://yeoman.io/.</a> Webapp использует sass, а я бы хотела less или вообще stylus, а еще - jade в качестве шаблонизатора. Поэтому я выбрала Yeogurt - он показался мне более универсальным, потому что на стадии создания проекта предоставляет возможность выбрать шаблонизатор - jade или nunjucks, препроцессор - Less, Sass, или Stylus, и инструменты тестирования - Jasmine или Mocha + Chai. В общем, можно собрать проект на любой вкус. Приятный бонус - возможность хранить контент в json-формате, а не вписывать его статично в шаблон.</p>

<p>Итак, приступим. Node.js у вас конечно же установлен, но если он давно не обновлялся, лучше взять версию посвежее, иначе Yeoman будет ругаться.</p>

<p>Устанавливаем основной инструментарий глобально:</p>

<pre><code>npm install -g yo bower grunt-cli gulp  
</code></pre>

<p>Теперь нужно поставить генератор, создать папку проекта и запустить его:</p>

<pre><code>npm install -g generator-yeogurt
mkdir my-new-project &amp;&amp; cd $_
yo yeogurt
</code></pre>

<p>Отвечаем на вопросы генератора, и вуаля - болванка для проекта готова. Запускаем сервер:</p>

<pre><code>gulp serve
</code></pre>

<p>Чтобы увидеть стартовую страницу проекта, нужно зайти на localhost:3000. Это дефолтный адрес, можно вписать любой порт в файл package.json, если 3000 у вас уже чем-то занят.</p>

<pre><code class="json package.json">
  "config": {
    "//": "Local Server Settings",
    "host": "127.0.0.1",
    "port": "3000",
    "baseUrl": "./",

} 
</code></pre>

<p>В документации есть описание структуры проекта - что в каких каталогах лежит, впрочем, все достаточно очевидно <a href="https://github.com/larsonjj/generator-yeogurt#page">https://github.com/larsonjj/generator-yeogurt#page</a></p>

<p>Кстати, в проект заботливо включен и .gitignore файл, так что об этом беспокоиться тоже не нужно.</p>

<p>Окружение готово. Осталось понять, как оно может облегчить жизнь разработчику. Допустим, я хочу создать header для сайта. Для этого можно воспользоваться генератором модулей. Нужно запустить команду:</p>

<pre><code class="bash">
yo yeogurt:module header
</code></pre>

<p>И в ответ получим сообщение о том, что  следующие файлы созданы:</p>

<pre><code class="bash">
   create src/_modules/header/header.jade
   create src/_modules/header/header.js
   create src/_modules/header/tests/header.test.js
   create src/_modules/header/header.styl
</code></pre>

<p>Посмотрим, что там нагенерировалось. В файле header.jade что-то не похожее на привычный html:</p>

<pre><code class="jade header.jade ">
mixin header(spec)
  - spec = spec || {}
  - spec.__class = spec.__class || ''

  div(class=spec.__class)&amp;attributes(attributes)
    p This is an example paragraph for the header module
</code></pre>

<p>Поэтому здесь потребуется небольшое лирическое отступление и помощь документации с сайта <a href="http://jade-lang.com/.">http://jade-lang.com/.</a> Миксин - это код, который можно использовать многократно, передавая ему разные параметры, то есть, что-то вроде функции. Например, чтобы отобразить содержимое header.jade,
нужно подключить его в файле index.jade, вот так:</p>

<pre><code class="jade index.jade">
include _modules/header/header
</code></pre>

<p>Расширение файла писать не обязательно, jade достаточно умен, чтобы не пытаться подключать js или css :)</p>

<p>Затем надо вставить сам миксин, например, так:</p>

<pre><code class="jade index.jade">
block content
  div #[+header]
</code></pre>

<p>Теперь переходим в браузер, и даже не нужно жать F5, чтобы обновить страницу - gulp уже сделал это в момент сохранения .jade файла - изменения уже видны. Но в случае с header’ом польза миксеров недостаточно очевидна. Лучше это ясно на примере с миксином field. Генерируем модуль с таким названием:</p>

<pre><code class="bash">yo yeogurt:module field
</code></pre>

<p>Получается то же самое, что и в предыдущем примере. Открываем файл field.jade и заменяем дефолтный код на наш собственный:</p>

<pre><code class="jade field.jade ">mixin field(name, type, value, placeholder)
  input(type=type, name=name, value=value, placeholder=placeholder)
</code></pre>

<p>В index.jade вставляем миксины с параметрами:</p>

<pre><code class="jade index.jade">
include _modules/field/field

block content
  div #[+header]

 #[+field('name', 'text', '', 'Enter your name')]
 #[+field('email', 'email', '', 'Enter e-mail address')]
</code></pre>

<p>Конечно, если нужно добавить всего пару полей, создавать миксин нет смысла, но для повторяющихся элементов - например, на страницах с длинными формами регистраций или заявок, эта возможность очень полезна. Вообще, jade - это тема для отдельного поста, поэтому тут я с ним, пожалуй, закруглюсь, и оставлю вот эту ссылку -
<a href="https://medium.com/@_jh3y/why-dont-more-people-know-about-use-jade-an-intro-to-jade-5c34422c9b4d#.6tqyps5rx">https://medium.com/@_jh3y/why-dont-more-people-know-about-use-jade-an-intro-to-jade-5c34422c9b4d#.6tqyps5rx</a></p>

<p>Теперь мне не терпится попробовать возможность хранить контент в json-файлах. Надо создать один такой для меню сайта в шапке:</p>

<pre><code class="json src/_data/menu.json">
[
  {
    "name" : "Home",
    "link" : "/"
  }, 
  {
    "name" : "About",
    "link" : "/about"
  },
  {
    "name" : "Contacts",
    "link" : "/contacts"
  }

]
</code></pre>

<p>Для вывода массива можно воспользоваться функцией итерации в jade. Это будет выглядеть так:</p>

<pre><code class="jade header.jade">
    ul
      each val, index in site.data.menu
        li
          a(href=val.link)= val.name
</code></pre>

<p>Лаконично, красиво и никаких незакрытых тегов. И вот оно - меню в шапке готово.</p>

<p>Теперь добавим стили. Stylus позволяет придерживаться такой же простоты синтаксиса в css. Для начала импортируем файл модуля header в  _styles/main.styl</p>

<pre><code class="css _styles/main.styl">
@import '../_modules/header/header';
</code></pre>

<p>Теперь можно делать все что угодно - выкинуть из кода все скобки, двоеточия и точки с запятыми, вводить переменные, задавать сложные селекторы отступами:</p>

<pre><code class="css _modules/header/header.styl">
font-size = 14px
font-family = 'PT Sans', Arial
link-color = #0266d6
ul
  li
    display inline-block
    font font-size font-family

    a:link, a:visited, a:active
      color link-color
</code></pre>

<p>Меньше кликов по клавиатуре, меньше кода, меньше вероятность ошибок - больше продуктивности и денег за качественно выполненную работу :) А Gulp и Yeoman сконвертируют в продакшн привычный css, понятный браузерам. Чтобы узнать про Stylus больше - добро пожаловать на офф. сайт <a href="http://stylus-lang.com/.">http://stylus-lang.com/.</a> В Stylus, как и в jade, есть возможность создавать миксины, функции и прочие приятные девелоперскому глазу штучки.</p>

<p>Во всем этом великолепии мне не хватает возможности автоматической генерации спрайтов, но это можно исправить самостоятельно - вот полезная статья на эту тему <a href="http://habrahabr.ru/post/227945/.">http://habrahabr.ru/post/227945/.</a> Я попробовала, все сработало отлично. Главное - не забыть добавить таск  к build и serve, чтобы спрайты создавались при запуске проекта.</p>

<pre><code class="js gulpfile.js">
// Build production-ready code
gulp.task('build', [
  'sprite',
  'copy',
  'imagemin',
  'jade',
  'stylus',
  'browserify'
]);

// Server tasks with watch
gulp.task('serve', [
  'sprite',
  'imagemin',
  'copy',
  'jade',
  'stylus',
  'browserify',
  'browserSync',
  'watch'
]);
</code></pre>

<p>Итак, меню у нас есть, а страниц, на которые оно ссылается - нету. Это легко исправить при помощи все того же генератора. Не требуется создавать файл вручную, достаточно выполнить в терминале команду</p>

<pre><code>yo yeogurt:page about
</code></pre>

<p>Но на ней нет шапки сайта! Тут я поняла свою ошибку и переподключила header в файл _layouts/base.jade</p>

<pre><code class="jade _layouts/base.jade">
include ../_modules/header/header
  block header
    div #[+header]
</code></pre>

<p>Из файла index.jade все, что касается модуля header можно удалить.</p>

<p>Аналогичным способом можно подключить в layout подвал сайта и другие элементы, или можно даже сгенерировать новый layout:</p>

<pre><code>yo yeogurt:layout one-col
</code></pre>

<p>и создавать страницы, отличные от дефолтных, передавая параметр в команде</p>

<pre><code>yo yeogurt:page contacts --layout=one-col
</code></pre>

<p>Когда работа над дизайном будет закончена, нужно запустить команду</p>

<pre><code>gulp --production
</code></pre>

<p>чтобы получить версию сайта с минифицированным js/css и сжатыми картинками.</p>

<p>Теперь все готово для того, чтобы делать реальный проект с использованием продвинутых фронтэнд-технологий вместо старого-доброго html/css.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Как сделать простое мобильное приложение с помощью Apache Cordova и AngularJS]]></title>
    <link href="http://nim-f.github.io/blog/2016/01/06/make-simple-mobile-app-with-cordova-and-angularjs/"/>
    <updated>2016-01-06T10:50:21+02:00</updated>
    <id>http://nim-f.github.io/blog/2016/01/06/make-simple-mobile-app-with-cordova-and-angularjs</id>
    <content type="html"><![CDATA[<p>Все мои планы на долгие рождественские выходные полетели коту под хвост из-за погоды. Сначала снег, а я на летней резине. Потом оттепель, гололед, лужи, дождь, туман, все разом - от одного взгляда за окно хочется еще глубже залезть под одеяло. Вместо того, чтобы слоняться по дому в тоске, я решила попробовать то, чего никогда не делала - написать мобильное приложение и поставить его на свой android-смартфон. А в случае успеха написать небольшой гайд для таких же новичков, как я.</p>




<p>Cordova - это open-sourse проект, позволяющий создавать программы для мобильных устройств, используя стандартные инструменты веб-разработчика: HTML, CSS и Javascript. По сути, мы просто пишем сайт, а потом запускаем в консоли волшебную команду, и она превращает его в приложение для выбранных платформ. Документация в подробностях здесь - <a href="https://cordova.apache.org" target="_blank">www.cordova.apache.org</a>, и я постараюсь ее не пересказывать, а сосредоточиться  на руководстве к действию.</p>




<!-- more -->




<p>Вот что должно получиться в результате:</p>


<p><img src="http://nim-f.github.io/images/listimg.png" alt="shopList app" /></p>

<p>Я решила сделать простую программку для ведения списков - будь то список продуктов для похода в магазин или to-do list, потому что все имеющиеся в google play бесплатные программы угнетают меня своим дизайном или обилием ненужных функций.</p>




<p>Описание установки рабочего окружение актуально для OS X и других unix систем, но не думаю, что на Windows порядок действий будет радикально отличаться.</p>




<p>Итак, предположим, что Node.js и git у Вас уже установлены. Ставим Cordova:</p>


<pre><code class="">npm install -g cordova
</code></pre>

<p>Затем, чтобы запускать эмулятор и делать билд приложения, нужно установить всю требуху для выбранной платформы - iOS, android, windows или еще какой-нибудь. Полный список поддерживаемых платформ и фич <a href="https://cordova.apache.org/docs/en/latest/guide/support/index.html" target="_blank">все там же</a></p>




<p>Моя цель - android, поэтому поставить пришлось следующее:</p>




<ul>
<li>Java</li>
<li>Java SE Development Kit</li>
<li>Android SDK</li>
</ul>




<p>Теперь можно создавать проект, точно так же, как описано в официальной документации:</p>


<pre><code class="">cordova create hello com.example.hello HelloWorld
cd hello
cordova platform add android
cordova platform add browser
</code></pre>

<p>И запускаем билд.</p>


<pre><code class="">cordova build
</code></pre>

<p>Если все пройдет гладко, вы увидите в терминале многабукаф и надпись "BUILD SUCCESSFUL" в самом конце.</p>




<p>Я, помимо андроида, добавила в список платформ браузер, потому что для меня отлаживать разметку и css так гораздо удобнее, чем каждый раз перезапускать эмулятор или ставить новую версию приложения на физическое устройство.</p>




<p>Кстати, чуть не забыла - если до этого Вы не запускали андроид-эмулятор, то нужно будет его создать, но это просто, сообщение об ошибке в командной строке подскажет вам, как.</p>




<p>Запускаем только что созданный шаблон приложения в эмуляторе:</p>


<pre><code class="">cordova emulate android
</code></pre>

<p>Или в браузере:</p>


<pre><code class="">cordova run browser
</code></pre>

<p>Или устанавливаем и запускаем на живом устройстве:</p>


<pre><code class="">cordova run android
</code></pre>

<p>Перед нами дефолтная болванка программы с логотипом Кордовы и надписью "device is ready". Все дальнейшие изменения нужно производить в каталоге www. При запуске любой из указанных выше трех команд или </p>


<pre><code class="">cordova build
</code></pre>

<p>Cordova сама сгенерирует нам правильный код и сложит его в папку platforms, в которой мы пока что ничего не трогаем.</p>




<p>Чтобы сделать задачу более интересной, я решила использовать AngularJS. Этот фреймворк сейчас в моде, значит надо попробовать и понять, почему все так любят его, а не какой-нибудь Backbone.js.</p>




<p>В этом случае нам здорово облегчит жизнь <a href="http://ngcordova.com/" target="_blank">ngCordova</a>. Это прослойка между angular и плагинами cordova, предоставляющая тонну возможностей в минимуме кода.</p>




<p>Открываем index.html в папке www и подключаем скрипты:</p>


<pre><code class="html index.html">        &lt;!-- собственно ангуляр --&gt;
        &lt;script type="text/javascript" src="js/angular.min.js"&gt;&lt;/script&gt;
        &lt;!-- библиотека для событий touch и swipe на сенсорных девайсах --&gt;
        &lt;script type="text/javascript" src="js/angular-touch.min.js"&gt;&lt;/script&gt;
        &lt;!-- ngCordova должна быть подключена после ангуляра, но до самой Cordova--&gt;
        &lt;script type="text/javascript" src="js/ng-cordova.js"&gt;&lt;/script&gt;
        &lt;!-- Cordova.js был по дефолту --&gt;
        &lt;script type="text/javascript" src="cordova.js"&gt;&lt;/script&gt;
        &lt;!-- файл контроллера для нашего приложения --&gt;
        &lt;script type="text/javascript" src="js/controllers.js"&gt;&lt;/script&gt;
        &lt;!-- дефолтный index.js - предлагаю его пока не удалять, а просто закомментить его содержимое, мало ли, вдруг пригодится --&gt;
        &lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt;
</code></pre>

<p>Дальше самое простое - разметка. Нам нужен заголовок, список и текстовое поле с кнопкой. Да здравствует минимализм! </p>


<pre><code class="html index.html">    &lt;body&gt;
        &lt;div class="app"&gt;
            &lt;h1&gt;Shop List&lt;/h1&gt;
            &lt;ul class="list"&gt;
                &lt;li&gt;
                    //тут будет содержимое списка
                &lt;/li&gt;
                &lt;li ng-bind="new_item" ng-show="new_item"&gt;&lt;/li&gt;
            &lt;/ul&gt;
            &lt;div class="add-item"&gt;
                &lt;input type="text" value="" /&gt;
                &lt;div class="button" value=""&gt;Add&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;           
</code></pre>

<p>Теперь очередь контроллера. Записываем в него массив с нашим списком покупок (пока что статично) и функцию добавления нового элемента в список.</p>


<pre><code class="js controllers.js">
var shopList = angular.module('shopList', ['ngCordova', 'ngTouch']);

shopList.controller('ItemsListCtrl', function ($scope) {
    $scope.items = [
        {"name": "Bread", "qty": 1, "status": false, "priority": 0},
        {"name": "Fruits", "qty": 1, "status": false, "priority": 0},
        {"name": "Water", "qty": 1, "status": false, "priority": 0}

    ];
});

    $scope.add = function(name) {

        var itemObj = {
            'name': name,
            'qty': 1,
            'status': false,
            'priority': 0
        };
        if ($scope.items) {
            $scope.items.push(itemObj);
        } else {
            $scope.items = [];
            $scope.items.push(itemObj);

        }

        $scope.new_item = "";
    };
</code></pre>

<p>Вносим соответствующие изменения в шаблон - добавляем контроллер к тегу body, ng-repeat из массива к li, привязываем к текстовому полю модель new_item, а к кнопке - функцию добавления новой записи.</p>


<p>
``` html
    <body ng-app="shopList">
        <div class="app" ng-controller="ItemsListCtrl">
            <h1>Shop List</h1>
            <ul class="list">
                <li ng-repeat="item in items track by $index">
                    {{item.name}}
                </li>
                <li ng-bind="new_item" ng-show="new_item"></li>
            </ul>
            <div class="add-item">
                <input type="text" value="" ng-model="new_item" />
                <div class="button" value="" ng-click="add(new_item)">Add</div>
            </div>
        </div>
   </body></p>

<p>```
</p>

<p>На css подробно останавливаться не буду. В конце статьи есть ссылка на репозиторий с кодом, можно использовать css-файл оттуда или написать самостоятельно.</p>




<p>Если сейчас вы запустите команду</p>


<pre><code class="">cordova run browser
</code></pre>

<p>или </p>


<pre><code class="">cordova run android
</code></pre>

<p>то приложение будет работать - добавлять запись в список. Но если его перезапустить, новые данные не сохранятся. Поэтому надо записывать их в какое-нибудь постоянное хранилище. </p>




<p>Официальная документация предлагает несколько <a href="https://cordova.apache.org/docs/en/4.0.0/cordova/storage/storage.html" target="_blank">вариантов</a>. Я воспользуюсь двумя, которые мне кажутся самыми простыми - localStorage и запись в файл.</p>




<p>Для начала рассмотрим localStorage - это легче всего, не нужны никакие дополнительные плагины, просто сохраняем массив с объектами в строку и записываем. Нужно добавить следующий код в конец функции add:</p>


<pre><code class="js controllers.js">
        var data = JSON.stringify($scope.items);
        //Save to localStorage
        localStorage.setItem('data', data);
</code></pre>

<p>И в самое начало контроллера, вместо статичного массива:</p>


<pre><code class="js controllers.js">
shopList.controller('ItemsListCtrl', function ($scope, $cordovaFile) {
    //Load from localStorage
    $scope.items = JSON.parse(localStorage['data']);

    ...
}
</code></pre>

<p>Можно оставить так или же записывать наши данные в файл. Я выбираю второй вариант. Для него потребуется использовать модуль <a href="http://ngcordova.com/docs/plugins/file/" target="_blank">File</a> из ngCordova.</p>




<p>Удаляем (или комментируем) код про localStorage, и вместо него добавляем вот это:</p>


<pre><code class="js controllers.js">
shopList.controller('ItemsListCtrl', function ($scope, $cordovaFile) {

   document.addEventListener("deviceready", function () {
        $scope.listPath = cordova.file.externalRootDirectory;
        //Read from file
        $cordovaFile.readAsText($scope.listPath, "list.json").then(function(result) {
            $scope.items = JSON.parse(result);
        }, function(err) {
            alert('Error! ' + err);
        });
    }, false);

    ...
}
</code></pre>

<p>Этот плагин будет читать информацию из файла и в случае успеха возвращать строку, которую необходимо сконвертировать в объект для дальнейшего использования, а в случае ошибки - выводить алерт с ее описанием. Но чтобы что-то прочитать, нужно сначала что-то записать! Добавляем функцию writeFile.</p>


<pre><code class="js controllers.js">
    $scope.writeFile = function(){
        var data = JSON.stringify($scope.items);
        $cordovaFile.writeFile($scope.listPath, "list.json", data, true).then(function(result) {
        }, function(err) {
            alert('Error! ' + err);
        });
    };
</code></pre>

<p>И используем ее в функции add вместо записи в localStorage:</p>


<pre><code class="js controllers.js">
    $scope.add = function(name) {
        var itemObj = {
            'name': name,
            'qty': 1,
            'status': false,
            'priority': 0
        };
        if ($scope.items) {
            $scope.items.push(itemObj);
        } else {
            $scope.items = [];
            $scope.items.push(itemObj);

        }

        $scope.new_item = "";

        var data = JSON.stringify($scope.items);
        //Save to file
        $scope.writeFile();
    };
</code></pre>

<p>Вот и все, теперь все данные записаны в файле. Я записала их в externalRootDirectory, просто потому что мне так захотелось (а еще потому, что так при переустановке приложения во время разработки файл не перезаписывается), но правильнее было бы использовать applicationStorageDirectory или externalApplicationStorageDirectory, чтобы не увеличивать энтропию во вселенной.</p>




<p>Теперь мы можем добавлять пункты в список, и они точно никуда не денутся, потому что возможности удаления в программе пока не предусмотренно :) Но это легко исправить. Как лучше реализовать удаление пункта меню в нашем минималистичном интерфейсе? Сделать кнопку? Нет, так мне не нравится, лучше добавить возможность вывода меню по долгому нажатию на пункт списка. Пока что в этом меню будет только одна опция - "Delete", но впоследствии можно будет добавить туда что-нибудь еще.</p>




<p>Реализуем это с помощью директивы, которая будет ловить событие долгого нажатия. Я не писала ее сама, а взяла отсюда: <a href="https://gist.github.com/BobNisco/9885852" target="_blank">https://gist.github.com/BobNisco/9885852</a></p>


<pre><code class="js controllers.js">
var shopList = angular.module('shopList', ['ngCordova', 'ngTouch']).
directive('onLongPress', function($timeout) {
        return {
            restrict: 'A',
            link: function($scope, $elm, $attrs) {
                $elm.bind('touchstart', function(evt) {
                    // Locally scoped variable that will keep track of the long press
                    $scope.longPress = true;

                    // We'll set a timeout for 600 ms for a long press
                    $timeout(function() {
                        if ($scope.longPress) {
                            // If the touchend event hasn't fired,
                            // apply the function given in on the element's on-long-press attribute
                            $scope.$apply(function() {
                                $scope.$eval($attrs.onLongPress)
                            });
                        }
                    }, 600);
                });

                $elm.bind('touchend', function(evt) {
                    // Prevent the onLongPress event from firing
                    $scope.longPress = false;
                    // If there is an on-touch-end function attached to this element, apply it
                    if ($attrs.onTouchEnd) {
                        $scope.$apply(function() {
                            $scope.$eval($attrs.onTouchEnd)
                        });
                    }
                });
            }
        };
});
</code></pre>

<p>Так же, как в примере, добавляем обработчик события:</p>


<pre><code class="js controllers.js">
    $scope.itemOnLongPress = function(index) {
        $scope.items[index].menu = true;
    };
</code></pre>

<p>С его помощью а также благодаря встроенной директиве ng-show в шаблоне можно изменять видимость контекстного меню для каждого пункта.</p>


<p></p>

<pre><code class="html index.html">&lt;li ng-repeat="item in items track by $index" on-long-press="itemOnLongPress($index)"&gt;
    {{item.name}}
    &lt;div class="item-menu" ng-show="item.menu" ng-init="item.menu = false"&gt;
        &lt;ul&gt;
            &lt;li ng-click="delete($index)"&gt;Remove&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre>

<p></p>

<p>Внимательные могли заметить, что я уже добавила вызов функции delete, теперь надо написать саму эту функцию, которая будет удалять указанный объект из массива и перезаписывать файл. Параметр $index обозначает порядковый номер элемента в массиве, начиная с нуля.</p>


<pre><code class="js controllers.js">
    $scope.delete = function(index) {
        $scope.items.splice(index, 1);
        $scope.writeFile();
    };
</code></pre>

<p>Ну вот, теперь можно и добавлять, и удалять записи списка. Но чего-то не хватает... Я думаю, нужно как-то маркировать статус записи - выполнено/не выполнено. Я использую для этого иконки из FontAwesome - icon-check для пункта, помеченного выполненным, и icon-check-empty для пустого чекбокса.</p>




<p>Меняем разметку:</p>


<pre><code class="html index.html">
&lt;li ng-repeat="item in items track by $index" on-long-press="itemOnLongPress($index)" on-touch-end="itemOnTouchEnd($index)"&gt;
    &lt;i ng-class="{'icon-check-empty': !item.status, 'icon-check': item.status}" ng-click="changeStatus($index)"&gt;&lt;/i&gt;
    
... 
&lt;/li&gt;
</code></pre>

<p>И добавляем функцию для переключения статуса:</p>


<pre><code class="js controllers.js">
    $scope.changeStatus = function(index) {
        $scope.items[index].status = !$scope.items[index].status;
        $scope.writeFile();
    };
</code></pre>

<p>Теперь сделанные дела и купленные продукты можно пометить галочкой, все как у тру-девелоперов, хаха :) </p>




<p>Итак, у нас есть законченное приложение, которое выполняет свои функции, и ушло на его создание всего несколько часов (вкуривание документации в эти часы тоже входит). Писала пост об этом я гораздо дольше, чем делала само приложение! </p>




<p>Теперь можно подключить свой телефон, включить отладку по USB, установить приложение и наслаждаться своим могуществом)</p>




<p>Полный код здесь: <a href="https://github.com/rthewheel/shopList/" target="_blank">https://github.com/rthewheel/shopList/</a>

Но он, возможно, будет изменяться.</p>



]]></content>
  </entry>
  
</feed>
